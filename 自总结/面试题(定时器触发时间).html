<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>1、什么是CSS？2、在js的计时器运行原理是怎样的？为什么可以触发计时器的效？计时器是多线程的吗?</title>
</head>
<body>
  <script>
    /*

            【什么是CSS】
            CSS是W3C组织提出的一个标准 通过在页面中使用CSS可以制作非常漂亮的网页
            CSS层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML（标准通用标记语言的一个应用）
            或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。
            CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。
            特点：
            1.易于使用和修改
            2.多页面应用
            3.层叠
            4.页面压缩
            
-------------------------------------------------------------------------------------------------------------
        
        【在js的计时器运行原理是怎样的？为什么可以触发计时器的效？计时器是多线程的吗?】
        理解js的事件循环在平时的工作中还是挺有用的，它可以让我们清楚的知道事件的执行顺序，
        知道事件的走向，才能更好的驾驭Javascript。

           var id = setTimeout(fn, delay); 
           - 初始化一个计时器，然后在指定的时间间隔后执行。
           var id = setInterval(fn, delay); 
           - 和setTimeout有些类似，但它是连续调用一个函数（时间间隔是delay参数）直到它被取消。
           clearInterval(id);, clearTimeout(id); 
           - 使用计时器ID来取消计时器回调的发生

              单线程，即在某个特定的时刻只有特定代码能执行，并阻塞其他代码.
              单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。
             (1) 【JS为什么是单线程的】?
             JS最初被设计用在浏览器中,那么想象一下,如果浏览器中的JS是多线程的。
             场景描述:
             那么现在有2个进程,process1 process2,由于是多进程的JS,所以他们对同一个dom,同时进行操作
             process1 删除了该dom,而process2 编辑了该dom,同时下达2个矛盾的命令,浏览器究竟该如何执行呢?
             JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动以及操作DOM。
             这决定了它只能是单线程，否则会带来很复杂的同步问题。
             (2) 【JS为什么需要异步】?
             场景描述:  
             如果JS中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。
             对于用户而言,阻塞就意味着"卡死",这样就导致了很差的用户体验
             所以,JS中存在异步执行。
             (3) 【JS单线程又是如何实现异步的呢】?
             既然JS是单线程的,只能在一条线程上执行,又是如何实现的异步呢?
             是通过的事件循环(event loop),理解了event loop机制,就理解了JS的执行机制
            JS的执行机制：
            1、首先判断JS是同步还是异步,同步就进入主进程,异步就进入event table
            2、异步任务在event table中注册函数,当满足触发条件后,被推入event queue
            3、同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主进程中
            以上三步循环执行,这就是【event loop】    
        */

//------------------------------------------------------------------------------------------------------------------------

    // setTimeout(function () {
    //   console.log('this is test')
    // }, 2000);
    // setInterval(function () {
    //   console.log('demo')
    // }, 1000);

    //并不是上一次fn执行完了之后再过1000ms才开始执行下一次, setInterval并不管上一次的执行结果，而是每隔1000ms就将fn放入主线程队列，
    //而两次之间具体间隔多久就不一定了，跟setTimeout实际延迟时间类似，和JS执行情况有关。具体的延迟效果与内存等因素有关.

//------------------------------------------------------------------------------------------------------------------------
    // console.log("script start");

    // setTimeout(function () {
    //     console.log("setTimeout");
    // }, 1000);

    // console.log("script end");

    /*
    
      首先，程序输出 'script start' 和 'script end'，
      在大约1s之后输出了 'setTimeout' 。该程序的 'script end' 并没有等待1s之后输出，而是立即输出。
      这是因为 setTimeout 是一个异步的函数。
      意思也就是说当我们设置一个延迟函数的时候，当前脚本并不会阻塞，它只是会在浏览器的事件表中进行记录，
      程序会继续向下执行。当延迟的时间结束之后，事件表会将回调函数添加至事件队列（task queue）中，
      事件队列拿到了任务过后便将任务压入执行栈（stack）当中，执行栈执行任务，输出 'setTimeout'。
      
    */

//---------------------------------------------------------------------------------------------------------------------------------

    //【计时器是单线程的】
    // setTimeout(function () { while (true) { } }, 1000);
    // setTimeout(function () { alert('end 2'); }, 2000);
    // setTimeout(function () { alert('end 1'); }, 100);
    // alert('end');

//---------------------------------------------------------------------------------------------------------------------------------

// console.log(1);

// setTimeout(function(){
//     console.log(2);
// },3000);

// setTimeout(function(){
//     console.log(3)
// },4000);

// for (var i = 0;i<10;i++) {
//     console.log(4);
// }
// setTimeout(function(){
//     console.log(5);
// },1000);

//如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，
//那么先加入任务队列的先执行，尽管它里面设置的时间比另一个setTimeout的要大
//-------------------------------------------------------------------------------------------------------------

setTimeout(function(){
    console.log(2);
},400);

for (var i = 0;i<20000;i++) {
    console.log(4);
};

setTimeout(function(){
    console.log(3)
},300);

//如果setTimeout加入队列的阻塞时间大于两个setTimeout执行的间隔时间，
//那么先加入任务队列的先执行，尽管它里面设置的时间可能比另一个setTimeout的要大
//----------------------------------------------------------------------------

    /*
      javascript引擎是单线程，强迫异步事件排队等待被执行。
      原理：计时器通过设定一定的时间段（毫秒）来异步的执行一段代码。
      因为 Javascript 是一个单线程语言，计时器提供了一种绕过这种语言限制来执行代码的能力。
      计时器是单线程的，需要等待上一个执行完，如果上一个没有执行完，下一个需要 延迟执行，直到上一个执行完。
      setInterval 如果有足够的时间来执行（大于制定的延迟），那么它将会无延迟的一个紧接着一个执行。
    */

//---------------------------------------------------------------------------------------------------------------------------------
  </script>
</body>
</html>