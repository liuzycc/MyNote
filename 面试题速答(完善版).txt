1.什么是闭包
外部可以访问内部的局部变量
延长生命周期

2.js垃圾回收机制
当一个函数执行完，GC会自动回收掉创建的变量，当然闭包除外，如果外部有对其内存地址引用，则不释放的前提下,GC不会回收

3.ajax请求过程
1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3. 设置响应HTTP请求状态变化的函数
4. 发送HTTP请求
5. 获取异步调用返回的数据
6. 使用JavaScript和DOM实现局部刷新

4.Ajax 请求如何解析json数据
JSON.parse(responseText)

5.css3 动画 属性
2d : transform  : translate  rotate  scale
3d : 视距：perspective 开启 transform-style：preserve-3d  方向 transform-origin 动画：tranlate rotate

animation  
过度：transition all 1s 2s

6.html5有哪些新特性、如何区分 HTML 和 HTML5？
新特性：
1. 拖拽释放(Drag and drop) API 
2. 语义化更好的内容标签（header,nav,footer,aside,article,section）
3. 音频、视频API(audio,video)
4. 画布(Canvas) API
5. 地理(Geolocation) API
6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
7. sessionStorage 的数据在浏览器关闭后自动删除
8. 表单控件，calendar、date、time、email、url、search  
9. 新的技术webworker, websocket, Geolocation
如何区分： 
DOCTYPE声明新增的结构元素、功能元素

7.浏览器渲染页面过程  
浏览器会把HTML、SVG、XHTML三种格式的文件会产生一个DOM树；
Css，解析css会产生css规则树JavaScript会通过DOM apI 来操作DOM树 和 css规则树

8.jquery核心特点   $ jquery  优点：提升开发效率，链式编程，等

9.面向对象特性
抽象性， 需要通过核心数据和特定环境才能描述对象的具体意义
封装性， 封装就是将数据和功能组合到一起， 在js 中对象就是键值对的集合， 对象
将属性和方法封装起来， 方法将过程封装起来
继承性，将别人的属性和方法成为自己的，传统继承基于模板(类)，js 中继承基于 构
造函数

10.继承有几种
1. 原型链继承
2. 借用构造函数继承
3. 组合继承(原型+借用构造)
4. 原型式继承
5. 寄生式继承
6. 寄生组合式继承

11.混合继承的缺点 : 会继承没用的并重复的属性或方法，并且 如果继承的引用类型的属性，当另一个实例出来的时候，改变或增加一个属性，则另一个实例也会多出 或 变换成 另个修改过后的 结果

12.this 指向： setimeout 指向 window，普通函数指向 window,构造函数指向实例者，事件指向事件源，对象的方法指向方法所属对象

13.同源策略：端口，域名，协议 完全一致才可以，这是浏览器规定的

14. 同步异步 在开发中哪些是同步，哪些是异步：
同步是阻塞的，浏览器向服务器发送请求，服务器比较忙，浏览器一直等着（页面白屏），直到服务器返回数据，页面才可以正常显示；
异步是非阻塞的，浏览器向服务器请求数据，服务器比较忙，浏览器可以干自己原来的事情（显示页面），服务器返回数据的时候通知浏览器一声，浏览器把返回的数据再渲染到页面，局部更新。
	
同步有很多，正常js代码就是同步的，js是单线程的，
异步：定时器  ajax 等

15.跨域如何实现：
jsonp利用 script标签和回调 ,window.name(看应用场景)  服务器端 
CORS 反向代理 原理：服务器请求服务器再把资源返回给页面上 
(JSONP 由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON 数据。
优点： 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest 或 ActiveX 的支持； 能够直接访问响应文本，支持在浏览器与服务器之间双向通信
缺点： JSONP 是从其他域中加载代码执行。如果其他域不安全，很可能会在响应中夹带一些 恶意代码，而此时除了完全放弃 JSONP 调用之外，没有办法追究。因此在使用不是你自己 运维的Web 服务时，一定得保证它安全可靠。 它只支持 GET请求而不支持 POST等其它类型的 HTTP 请求；它只支持跨域 HTTP 请 求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript调用的问题)

16.事件绑定和普通事件的区别：
普通事件不可以重复绑定，并且如果重复绑定会覆盖掉之前的
事件绑定可以重复绑定，不会重叠掉

17.ajax  get与post区别
两个请求方式， 不同在于get参数在url?k=v这种形式  post一般用户看不到相对安全 参数放在请求体form data中
GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符，有的浏览器是8000个字符
POST：一般用于修改服务器上的资源，对所发送的信息没有限制

18.状态码 302 304
301永久重定向
302临时重定向
304服务端资源未改变可以直接读取未过去的缓存数据

19.如何对网页进行优化(需要补充)
1、尽量减少 HTTP 请求
2、使用浏览器缓存
3、使用压缩组件
4、图片、JS的预载入
5、将脚本放在底部
6、将样式文件放在页面顶部
7、使用外部的JS和CSS
8、精简代码

20.通配符可以伪匹配的元素吗（不知道百度下）

21.rgba 与 opacity 透明度的区别
 rgba可以设置背景+透明度   opacity 是元素透明

22.清除浮动的方法有几种
1. 父级div定义 height
原理：父级 div手动定义 height，就解决了父级 div无法自动获取到高度的问题。 简单、
代码少、容易掌握 ，但只适合高度固定的布局.
2. 结尾处加空 div标签 clear：both
原理：在浮动元素的后面添加一个空div兄弟元素，利用 css 提高的clear：both清除浮动，
让父级div能自动获取到高度 ，如果页面浮动布局多，就要增加很多空 div，让人感觉很
不好 .
3. 父级div定义 伪类：after 和 zoom
/清除浮动代码/
.clearfix：after{
content：""；
display：block；
visibility：hidden；
height：0；
line-height：0；
clear：both；
}
.clearfix{zoom：1}
原理：IE8以上和非 IE浏览器才支持：after，原理和方法 2有点类似，zoom(IE专有属性)
可解决ie6，ie7 浮动问题 ，推荐使用，建议定义公共类，以减少CSS 代码。
4. 父级div定义 overflow：hidden
超出盒子部分会被隐藏，不推荐使用.
5. 双伪元素法：
.clearfix：before，.clearfix：after {
content： ""；
display： block；
clear：both；
}
.clearfix {
zoom： 1；}


23.精灵图的有缺点   
精灵图的优点：
      1. 减少图片的体积，因为每个图片都有一个头部信息，把多个图片放到一个图片里，就会共用同一个头部信息，从而减少了字节数。
      2. 减少了网页的http请求次数，从而加快了网页加载速度，提高用户体验。
      3. 解决了网页设计师在图片命名上的困扰，只需对一张集合的图片上命名就可以了，不需要对每一个小元素进行命名，从而提高了网页的制作效率。
      4. 更换风格方便，只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变。维护起来更加方便。
      
精灵图的缺点：
      1. 在图片合并的时候，你要把多张图片有序的合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景；这些还好，最痛苦的是在宽屏，高分辨率的屏幕下的自适应页面，你的图片如果不够宽，很容易出现背景断裂；
2. 在开发的时候比较麻烦，你要通过photoshop或其他工具测量计算每一个背景单元的精确位置，这是针线活，没什么难度，但是很繁琐；
      3. 在维护的时候比较麻烦，如果页面背景有少许改动，一般就要改这张合并的图片，无需改的地方最好不要动，这样避免改动更多的css，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动css。
      4. 精灵图不能随意改变大小和颜色。精灵图改变大小会失真模糊，降低用户体验，css3新属性可以改变精灵图颜色，但是比较麻烦，并且新属性有兼容问题。现在一般都是用web字体(图标字体)来代替精灵图。

24.window.onload 与 $(funciton) 区别
1.执行时间 window.onload必须等到页面内包括图片的所有元素加载完毕后才能执行。 $(document).ready()是 DOM 结构绘制完毕后就执行，不必等到加载完毕。
2.编写个数不同 window.onload不能同时编写多个，如果有多个 window.onload 方法，只会执 行一个 $(document).ready()可以同时编写多个，并且都可以得到执行
3.简化写法 window.onload没有简化写法
$(document).ready(function (){})
可以简写成$(function(){})；

25.DOM的增删改查
1. 创建节点、追加节点
createElement（标签名）创建一个元素节点（具体的一个元素）。
createTextNode（节点文本内容）创建一个文本节点。
createDocumentFragment() //创建一个 DOM 片段。
appendChild（节点）追加一个节点。

2. 插入节点
appendChild（节点）也是一种插入节点的方式，还可以添加已经存在的元素，会将其
元素从原来的位置移到新的位置。
insertBefore（a,b）是参照节点，意思是 a节点会插入 b节点的前面。

3. 删除、移除节点
removeChild(节点) 删除一个节点，用于移除删除一个参数（节点）。其返回的被移除
的节点，被移除的节点仍在文档中，只是文档中已没有其位置了。

4. 复制节点
cloneNode() 方法，用于复制节点， 接受一个布尔值参数， true 表示深复制（复制节点
及其所有子节点）， false 表示浅复制（复制节点本身，不复制子节点）。

5. 替换节点
replaceChild(插入的节点，被替换的节点) ，用于替换节点，接受两个参数，第一参数
是要插入的节点，第二个是要被替换的节点。返回的是被替换的节点。

6. 查找节点
getElementsByTagName() //通过标签名称
getElementsByName() //通过元素的Name 属性的值(IE容错能力较强，会得到一
个数组，其中包括 id等于 name值的)
getElementById() //通过元素 Id，唯一性


27.（根据题号来的）什么是与解析 
在代码整体执行之前，先解析一部分。
预解析之后，代码才会从上往下依次整体执行，但是预解析执行过的代码不会 重复执行。
js预解析干了什么事：js 中预解析会把声明部分的代码预先执行。
声明相关的代码可以分为两部分：
1、 变量声明 通过 var关键字定义的变量。
2、函数声明 通过 function关键字声明的函数
预解析时如果遇到重复的变量声明，那么忽略。
预解析时如果遇到重复的函数声明，保留后面的函数。
预解析时如果遇到变量与函数重名的情况，保留函数。

28.事件委托的机制 有什么优点(利用事件冒泡)
事件委托，就是某个事件本来该自己干的，但是自己不干，交给别人来干。就叫事件委 托。打个比方：一个button 对象，本来自己需要监控自身的点击事件，但是自己不来监控这个点击事件，让自己的父节点来监控自己的点击事件。
优点：
提高性能：列如，当有很多 li同时需要注册事件的时候，如果使用传统方法来注册 事件的话，需要给每一个 li 注册事件。然而如果使用委托事件的话，就只需要将事件委托给 该一个元素即可。这样就能提高性能。
新添加的元素还会有之前的事件；

29.301 302 403 404 500
301 永久重定向
302 临时重定向
403 资源不变，向未过期的缓存请求过来数据
404 未找到资源
500 服务器错误

30. CSS3新增伪类有那些？
p:first-of-type 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。
p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。
p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。
p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。
p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。
:enabled、:disabled 控制表单控件的禁用状态。
:checked，单选框或复选框被选中。

31.数组常用方法
Push()尾部添加 pop()尾部删除
Unshift()头部添加 shift()头部删除

32.如何能JQUery方法绑定多个事件(我就记得on了，有其他的补充下)
$(xx).on('click',fn)   bind 
addEventListner或attachEvent兼容不同的浏览器

33.闭包的特性对页面有什么影响
GC不能回收 内存空间不能被释放 导致资源的浪费 过多使用闭包会倒是内存溢出 如果性能NB的主机，那就尽情的挥霍吧

34.301 304
301永久重定向
304 在浏览器缓存中读取的数据

34.ajax怎么解析json数据
JSON.parse(data);

35.重复了

36.重复了

37.什么是事件冒泡，什么是事件捕获

事件流：事件捕获  目标元素 事件冒泡  三个阶段
事件冒泡就是 但触发一个元素的时候 会一层一层的向上传递  知道阻止或者 到document
事件捕获就是 当触发一个元素的时候要先经历捕获阶段 从 document 开始一层一层向下找
addEventListener('click'fn,true)捕获

38.创建函数的几种方式(好像还有1个忘记了 补充下)
第一种（函数声明）：?
function sum1(num1,num2){
? ?return num1+num2;
}
第二种（函数表达式）：
var sum2 = function(num1,num2){
? ?return num1+num2;
}
第三种（函数对象方式）：
var sum3 = new Function("num1","num2","return num1+num2");

39.重复了

40.4个常用的内置对象
Array\Math\Date\String

41.关于array 常用的方法  （重复了）

42.重复了

43.面向对象 和  面向过程 区别
面向对象  封装 继承 多态  以功能来实现
面向过程  一步一步来  按部就班 亲力亲为

44.事件委托（重复了）

45.什么是变量提升
js预编译  执行前把函数的声明 变量的声明 提升到文档顶部

46.重复了

47.原型链(忘记图怎么花了，需要补充)

原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链 

48.重复了

49.bfc	
指页面中的一个渲染区域，并且拥有一套渲染规则，他决定了其子元素如何定位，以及与其他元素的相互关系和作用。
overflow：hidden  可以出发bfc  内部布局会形成一个新的规则  

50.如何阻止事件冒泡(单词忘记了，抄的)
js e.stopPropagation  IE cancelBubble
jq return false

51.重复了

52.call apply 区别
都是改变this 指向的
参数不同  call(obj,c1,c2,c3..)  applay(obj,[c1,c2,c3..])

53.重复了

54.H5新增哪些新标签(快来补充一波)
HTML5：?nav,?footer,?header,?section,?hgroup,?video,?time,?canvas,?audio...

55.权重  
标签选择器 1
类选择器    10
ID         100
！import   1000
内联样式更大

56.css 特性
font相关属性会继承    

57.优雅降级  渐进增强 
渐进增强?progressive?enhancement：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。
优雅降级?graceful?degradation：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。
区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带。

58.什么是原型链（描述不清，回头看下吧）
原型对象也是普通的对象，是对象一个自带隐式的 __proto__ 属性，原型也有可能有自己的原型，如果一个原型对象的原型不为null的话，我们就称之为原型链。
*  原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链。

59.重复了

60.重复了

61.重复了

62.冲服了

63.ajax 响应数据类型有哪些(这东西死记)
html xml json script text jsonp


 